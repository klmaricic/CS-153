/* 
 * File:   heap.hpp
 * Author: joshua
 *
 * Created on April 12, 2012, 1:13 PM
 */

#ifndef HEAP_HPP
#define	HEAP_HPP

template<class T>
void Heap<T>::insert(const T& x) {
    BNode<T>* nu = new BNode<T> (x);

    rInsert(BinaryTree<T>::m_root, nu, 0);

    BNode<T>* temp = nu;
    while (temp->m_parent) {
        temp->m_parent->m_count++;
        temp = temp->m_parent;
    }
    
    heapifyUp(nu);
}

template<class T>
void Heap<T>::rInsert(BNode<T>* & root, BNode<T>* & nu, int depth) {
    if (root == NULL) {
        root = nu;
        BinaryTree<T>::m_size++;
        return;
    }

    if (root->m_left == NULL) {
        root->m_left = nu;
        nu->m_parent = root;
        BinaryTree<T>::m_size++;
        return;
    }

    if (root->m_right == NULL) {
        root->m_right = nu;
        nu->m_parent = root;
        BinaryTree<T>::m_size++;
        return;
    }

    if (isFull(root, depth)) {
        
        BNode<T>* temp =  root->m_left;
        
        while(temp->m_left != NULL)
            temp = temp->m_left;
        

        temp->m_left = nu;
        nu->m_parent = temp;
        BinaryTree<T>::m_size++;
        return;
    }

    if (!isFull(root->m_left, depth + 1)) {
        rInsert(root->m_left, nu, depth + 1);
        return;
    } else {
        rInsert(root->m_right, nu, depth + 1);
        return;
    }

}

template<class T>
void Heap<T>::heapifyUp(BNode<T>* node) {
    if (node == NULL || node->m_parent == NULL)
        return;
    if (node->m_data > node->m_parent->m_data) {
        T temp = node->m_data;
        node->m_data = node->m_parent->m_data;
        node->m_parent->m_data = temp;

        heapifyUp(node->m_parent);
    }

}


#endif	/* HEAP_HPP */

