//PROGRAMMER: KELSEY MARICIC
//PROGRAM: digraph.hpp

template<class T, unsigned int A>
DirectedGraph<T, A>::DirectedGraph() 
{
  m_size = A;

  vertices.resize(m_size);
  
  for (int i = 0; i < m_size; i++) 
  {
    vertices[i] = Vertex<T > (i);
  }
  
  edgeList.resize(m_size);
}

template<class T, unsigned int A>
void DirectedGraph<T, A>::clear()
{
  edgeList.clear();
  vertices.clear();
  m_size = 0;
}

template<class T, unsigned int A>
void DirectedGraph<T, A>::addEdge(const unsigned int i,const unsigned int j, const int w) 
{
  if (i >= m_size || j >= m_size)
    throw std::out_of_range("Out of range.");

    Edge e(i, j, w);
    bool d = false;
	
    for (int z = 0; z < edgeList[i].size(); z++) 
	{
      if (edgeList[i][z].isSameEdge(e)) 
	  {
        d = true;
        break;
      }
    }

    if (!d)
      edgeList[i].push_back(e);
}

template<class T, unsigned int A>
void DirectedGraph<T, A>::removeEdge(const unsigned int i, const unsigned int j) 
{
  if (i >= m_size || j >= m_size)
    throw std::out_of_range("Out of range.");

  for (int index = 0; index < edgeList[i].size(); index++) 
  {
    if (edgeList[i][index].isSameEdge(i, j)) 
	{
      edgeList[i].erase(edgeList[i].begin() + index);
    }
  }
}

template<class T, unsigned int A>
bool DirectedGraph<T, A>::find(const T& x) const 
{
  for (int i = 0; i < vertices.size(); i++) 
  {
    if (vertices[i].m_data == x)
      return true;
  }

    return false;
}

template<class T, unsigned int A>
T DirectedGraph<T, A>::getVertexData(const unsigned int i) const 
{
  if (i >= m_size)
    throw std::out_of_range("Out of range.");
    
  return vertices[i].m_data;
}

template<class T, unsigned int A>
void DirectedGraph<T, A>::setVertexData(const unsigned int i, const T& data) 
{
  if (i >= m_size)
    throw std::out_of_range("Out of range");
    
  vertices[i].m_data = data;
}

template<class T, unsigned int A>
bool DirectedGraph<T, A>::isEdge(const unsigned int i, const unsigned int j) const 
{
  if (i >= m_size || j >= m_size)
    throw std::out_of_range("Out of range.");

  for (int index = 0; index < edgeList[i].size(); index++) 
  {
    if (edgeList[i][index].isSameEdge(i, j))
      return true;
  }
   
  return false;
}

template<class T, unsigned int A>
int DirectedGraph<T, A>::getEdgeWeight(const unsigned int i, const unsigned int j) const 
{
  if (i >= m_size || j >= m_size)
    throw std::out_of_range("Out of range.");

  for (int index = 0; index < edgeList[i].size(); index++) 
  {
    if (edgeList[i][index].isSameEdge(i, j))
      return edgeList[i][index].m_weight;
  }
  
  return 0;
}

template<class T, unsigned int A>
void DirectedGraph<T, A>::setEdgeWeight(const unsigned int i,const unsigned int j, const int w) 
{
  if (i >= m_size || j >= m_size)
    throw std::out_of_range("Out of range.");

  for (int index = 0; index < edgeList[i].size(); index++) 
  {
    if (edgeList[i][index].isSameEdge(i, j)) 
	{
      edgeList[i][index].m_weight = w;
      break;
    }
  }
}

template<class T, unsigned int A>
int DirectedGraph<T, A>::vertexOutDegree(const unsigned int i) const 
{
  if (i >= m_size)
    throw std::out_of_range("Out of range.");

  int correction = 0;
  for (int j = 0; j < edgeList[i].size(); j++) 
  {
    for (int k = 0; k < edgeList[i].size(); k++) 
	{
      if (edgeList[i][j].isSameEdge(edgeList[i][k].m_u, edgeList[i][k].m_v) && k != j)
        correction += 1;
    }
  }

  return edgeList[i].size() - correction / 2;
}

template<class T, unsigned int A>
int DirectedGraph<T, A>::vertexInDegree(const unsigned int i) const 
{
  if (i >= m_size)
    throw std::out_of_range("Out of range.");

  std::vector<Edge> edges;


  int numDuplicates = 0;

  for (int j = 0; j < edgeList.size(); j++) 
  {
    for (int k = 0; k < edgeList[j].size(); k++) 
	{
      if (edgeList[j][k].m_v == i) 
	  {
        edges.push_back(edgeList[j][k]);
      }
    }
  }

  for (int j = 0; j < edges.size(); j++) 
  {
    for (int k = 0; k < edges.size(); k++) 
	{
      if (edges[j].isSameEdge(edges[k]) && k != j)
        numDuplicates += 1;
    }
  }
  
  if (numDuplicates != 0)
    numDuplicates /= 2;

  return edges.size() - numDuplicates;
}

template<class T, unsigned int A>
int DirectedGraph<T, A>::graphDegree() const 
{
  int total = 0;

  for (int i = 0; i < m_size; i++) 
  {
    total += vertexInDegree(i);
    total += vertexOutDegree(i);
  }

  return total;
}

template<class T, unsigned int A>
bool DirectedGraph<T, A>::isSimple() const 
{
  for (int i = 0; i < edgeList.size(); i++) 
  {
    for (int j = 0; j < edgeList[i].size(); j++) 
	{
      if (edgeList[i][j].isSameEdge(i, i)) 
        return false;
    }
  }

  std::vector<Edge> allEdges;
    
  for (int i = 0; i < edgeList.size(); i++) 
  {
    for (int j = 0; j < edgeList[i].size(); j++) 
      allEdges.push_back(edgeList[i][j]);
  }

  for (int i = 0; i < allEdges.size(); i++) 
  {
    for (int j = 0; j < allEdges.size(); j++) 
	{
      if (allEdges[i].m_u == allEdges[j].m_v && allEdges[i].m_v == allEdges[j].m_u)
        return false;
    }
  }

  return true;
}

template<class T, unsigned int A>
bool DirectedGraph<T, A>::isComplete() const 
{
  if (!isSimple())
    return false;

  for (int i = 0; i < m_size; i++) 
  {
    for (int j = 0; j < m_size; j++) 
	{
      if ((j != i) && !(isEdge(i, j) || isEdge(j, i)))
        return false;
    }
  }

  return true;
}

template<class T, unsigned int A>
void DirectedGraph<T, A>::dfs(const unsigned int start, int visited[]) const 
{
  if (start >= m_size)
    throw std::out_of_range("Out of range.");

  visited[ start ] = true;
  std::vector<int> neighbors = getNeighbors(start);

  int n;
  for (int i = 0; i < neighbors.size(); i++) 
  {
    n = neighbors[i];
        
	if (visited[n] == false)
      dfs(n, visited);
  }
}

template<class T, unsigned int A>
void DirectedGraph<T, A>::bfs(const unsigned int start, int visited[]) const 
{
  if (start >= m_size)
    throw std::out_of_range("Out of range, breh.");

  using namespace std;
  queue<int> q;
    
  visited[start] = true;
  q.push(start);
  int f;
  vector<int> neighbors;
  
  while (!q.empty()) 
  {
    f = q.front();
    q.pop();
    neighbors = getNeighbors(f);
	
    int w;
        
    for (int z = 0; z < neighbors.size(); z++)
      w = neighbors[z];
        
    if (visited[w] == false) 
	{
      visited[w] = true;
      q.push(w);
    }
  }
}

template<class T, unsigned int A>
std::vector<int> DirectedGraph<T, A>::getNeighbors(int n) const 
{
  std::vector<int> ret(1);
  
  for (int j = 0; j < edgeList[n].size(); j++) 
    ret.push_back(edgeList[n][j].m_v);

  return ret;
}

